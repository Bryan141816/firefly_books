<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Vanilla EPUB Reader</title>
  <style>
    body {
      font-family: sans-serif;
      color: black;
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    #reader {
      overflow-y: auto;
      scroll-behavior: smooth;
      overflow-y: auto;
      scroll-behavior: smooth;
    }

    .chapter {
      padding: 20px;
      border-bottom: 1px solid black;
    }


    body.dark {
      color: white;

      .chapter {
        padding: 20px;
        border-bottom: 1px solid white;
      }


    }

    * {
      font-size: 1rem;
      background: transparent;
      line-height: 1.6;
      box-sizing: border-box;

    }

    body::-webkit-scrollbar {
      display: none;
    }

    #reader::-webkit-scrollbar {
      display: none;
    }
  </style>
</head>

<body>
  <div id="reader"></div>

  <script>
    /* --------------------------------------------------
       GLOBAL STATE
    -------------------------------------------------- */
    let zip;
    let chapters = [];
    let cssFiles = [];
    let chapterIds = [];
    let chapterElements = [];
    let bookLoaded = false;
    let startingScroll = 0;
    let isDarkMode = false;
    
    /* --------------------------------------------------
       HELPERS
    -------------------------------------------------- */
    function parseXml(xmlStr) {
      return new DOMParser().parseFromString(xmlStr, "application/xml");
    }

    function joinPaths(base, relative) {
      const stack = base.split("/");
      const parts = relative.split("/");
      if (stack[stack.length - 1].includes(".")) stack.pop();

      for (let part of parts) {
        if (part === "..") stack.pop();
        else if (part !== ".") stack.push(part);
      }
      return stack.join("/");
    }

    function parseHref(rawHref) {
      if (!rawHref) return null;
      if (rawHref.includes("#")) return rawHref.split("#")[1];
      return rawHref
        .split("/")
        .pop()
        .replace(/\.[^/.]+$/, "");
    }

    async function waitForLayoutStability(root = document) {
  // Wait for fonts (if any)
  if (document.fonts?.ready) await document.fonts.ready;

  // Wait for images to decode
  const imgs = Array.from(root.querySelectorAll("img"));
  await Promise.all(
    imgs.map(async (img) => {
      try {
        if (!img.complete) await new Promise((res, rej) => {
          img.addEventListener("load", res, { once: true });
          img.addEventListener("error", res, { once: true }); // don't block forever
        });
        if (img.decode) await img.decode().catch(() => {});
      } catch {}
    })
  );

  // Let layout/paint settle
  await new Promise((r) => requestAnimationFrame(() => requestAnimationFrame(r)));
}


    /* --------------------------------------------------
       IMAGE HANDLING
    -------------------------------------------------- */
    async function convertImages(html, chapterPath = "", basePath = "") {
      const doc = new DOMParser().parseFromString(html, "text/html");
      const imgs = doc.querySelectorAll("img");

      for (let img of imgs) {
        const src = img.getAttribute("src");
        if (!src) continue;

        let filePath = joinPaths(chapterPath, src);
        let file = zip.file(filePath);

        if (!file) {
          filePath = joinPaths(basePath, src);
          file = zip.file(filePath);
        }

        if (file) {
          // Option 1: directly as Blob (JSZip supports this)
          const blob = await file.async("blob");

          // Optional: ensure correct MIME type
          const ext = src.split(".").pop().toLowerCase();
          const mime =
            ext === "jpg" || ext === "jpeg" ? "image/jpeg" :
              ext === "png" ? "image/png" :
                ext === "gif" ? "image/gif" :
                  ext === "webp" ? "image/webp" :
                    "application/octet-stream";

          const typedBlob = blob.type ? blob : new Blob([blob], { type: mime });

          const blobUrl = URL.createObjectURL(typedBlob);
          img.src = blobUrl;
        }
      }

      return doc.body.innerHTML;
    }

    /* --------------------------------------------------
       CSS
    -------------------------------------------------- */
    async function injectCss(basePath = "") {
      for (let href of cssFiles) {
        const file = zip.file(basePath + href);
        if (!file) continue;

        const css = await file.async("text");
        const style = document.createElement("style");
        style.textContent = css;
        document.head.appendChild(style);
      }
    }

    function measureRelToChapter(node, chapterTop) {
      const rTop = node.offsetTop;
      const rBottom = rTop - node.offsetHeight;
      return {
        top: rTop - chapterTop,
        bottom: rBottom - chapterTop,
      };
    }

    function chooseCutNode(crossingLeaf, chapter, chapterTop, splitY, isGoodBlock = null) {
      // path = [chapter, ..., parent]
      const path = crossingLeaf.path;

      // Default "good block" heuristic: prefer elements that look like blocks
      const defaultIsGoodBlock = (el) => {
        const tag = el.tagName;
        // customize if you want (P, LI, SECTION, DIV, etc.)
        return tag === "P" || tag === "LI" || tag === "DIV" || tag === "SECTION" || tag === "ARTICLE";
      };
      const blockFn = isGoodBlock ?? defaultIsGoodBlock;

      // Find deepest ancestor that spans the split line
      let best = null;

      for (let i = path.length - 1; i >= 0; i--) {
        const node = path[i];
        if (node === chapter) continue;

        const { top, bottom } = measureRelToChapter(node, chapterTop);

        const spansSplit = top <= splitY && bottom >= splitY;
        if (!spansSplit) continue;

        // Prefer "block-like" containers first
        if (blockFn(node)) return node;

        // else keep candidate and continue searching deeper
        best = node;
      }

      // fallback: if nothing spans split (rare), cut at the leaf itself
      return best || crossingLeaf.leaf;
    }

    function splitChapterByHeight(chapter, winHeight, padding = 20) {
      // Important: reset globals if you keep them
      elementsCount = {};
      commonElement = null;

      const chapterTop = chapter.offsetTop;
      const leaves = getLeafElementsWithPath(chapter);

      const splitY = winHeight - padding; // split line inside chapter coords

      // Find first leaf that crosses the split line
      const crossing = leaves.find(({ leaf }) => {
        const { top, bottom } = measureRelToChapter(leaf, chapterTop);
        return top < splitY && bottom > splitY; // crosses the line
      });

      // If nothing crosses, just do a simple before/after by top
      if (!crossing) {
        const before = [];
        const after = [];
        for (const item of leaves) {
          const { top } = measureRelToChapter(item.leaf, chapterTop);
          (top < splitY ? before : after).push(item);
        }
        return { cutNode: null, before, after };
      }

      const cutNode = chooseCutNode(crossing, chapter, chapterTop, splitY);

      // Now split by DOM order: everything before cutNode vs cutNode+after
      const before = [];
      const after = [];
      let inAfter = false;

      for (const item of leaves) {
        if (!inAfter) {
          // If leaf is inside cutNode, we flip to "after"
          if (cutNode.contains(item.leaf)) inAfter = true;
        }
        (inAfter ? after : before).push(item);
      }

      return { cutNode, before, after };
    }


    /* --------------------------------------------------
       CHAPTER TRACKING
    -------------------------------------------------- */

    let intersectDebounce = null;

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) return;

          const index = Number(entry.target.dataset.index);

          // cancel previous debounce
          if (intersectDebounce) {
            clearTimeout(intersectDebounce);
          }

          // start new debounce
          intersectDebounce = setTimeout(() => {
            console.log(index)
            PageChanged.postMessage((index).toString());

            // setCurrentChapter(index);
            // sendToFlutter(index);
          }, 500);
        });
      },
      { threshold: 0.25 },
    );

    function refreshChapterIndex() {
      chapterElements = Array.from(document.querySelectorAll(".chapter"));
      computedChapterIds = chapterElements.map(el => el.id);

      // If you want to also overwrite chapterIds with the final list:
      chapterIds = [...computedChapterIds];
      // If you need to send to Flutter:
      // ChaptersIndexed.postMessage(JSON.stringify(computedChapterIds));
    }

    /* --------------------------------------------------
       RENDER
    -------------------------------------------------- */


    async function displayAllChapters() {
      const reader = document.getElementById("reader");
      reader.innerHTML = "";

      // Create and append all chapter elements first
      const winHeight = window.innerHeight;
      const fragment = document.createDocumentFragment();
      chapters.forEach((html, i) => {
        const div = document.createElement("div");
        div.className = "chapter";
        div.style.minHeight = `${winHeight}px`;

        div.id = chapterIds[i];
        div.innerHTML = html;
        fragment.appendChild(div);

      });
      reader.appendChild(fragment);

      // Now get references



      let elementsCount = {};
      let commonElement = null;
      function getLeafElementsWithPath(element, path = [], result = []) {
        const elementType = element.tagName;
        let newPath = [...path]
        if (commonElement && elementType == commonElement) {
          result.push({
            leaf: element,
            path: newPath
          });
          return result;
        }
        else if (element.children.length === 0) {
          if (elementsCount.hasOwnProperty(elementType)) {
            if (elementsCount[elementType] + 1 > 10) {
              commonElement = elementType;
            }
            else {
              elementsCount[elementType] = elementsCount[elementType] + 1;
            }
          }
          else {
            elementsCount[elementType] = 1;
          }
          result.push({
            leaf: element,
            path: newPath
          });
          return result;
        }
        else {
          newPath = [...path, element];
        }

        for (const child of element.children) {
          getLeafElementsWithPath(child, newPath, result);
        }

        return result;
      }
      function buildFromElementPaths(items, rootClone, {
        // clone containers (path nodes)
        cloneContainer = (el) => el.cloneNode(false), // shallow: tag+attrs, no children

        // clone leaves (usually deep)
        cloneLeaf = (leafEl) => leafEl.cloneNode(true),

        // keep siblings in original DOM order under the same parent
        preserveOriginalSiblingOrder = true,

        // optional: avoid duplicate IDs in the cloned tree
        stripIds = true,
      } = {}) {
        const cloneOf = new Map(); // original HTMLElement -> cloned HTMLElement
        const siblingSeen = new Map(); // originalParent -> Set(originalChild)

        function maybeStripId(cloneEl) {
          if (stripIds) cloneEl.removeAttribute("id");
          return cloneEl;
        }

        function getContainerClone(originalEl) {
          if (!cloneOf.has(originalEl)) {
            const c = cloneContainer(originalEl);
            maybeStripId(c);
            cloneOf.set(originalEl, c);
          }
          return cloneOf.get(originalEl);
        }

        function attachChild(originalParent, originalChild) {
          const parentClone = getContainerClone(originalParent);
          const childClone = getContainerClone(originalChild);

          // already attached correctly
          if (childClone.parentNode === parentClone) return;

          if (!preserveOriginalSiblingOrder) {
            parentClone.appendChild(childClone);
            return;
          }

          // Track which original children we’ve attached for this parent
          if (!siblingSeen.has(originalParent)) siblingSeen.set(originalParent, new Set());
          const set = siblingSeen.get(originalParent);
          set.add(originalChild);

          // Build ordered list by original DOM order
          const orderedOriginalChildren = Array.from(originalParent.children).filter((ch) => set.has(ch));

          // Rebuild the clone children in correct order (only those we’ve seen)
          parentClone.replaceChildren(...orderedOriginalChildren.map(getContainerClone));
        }

        for (const item of items) {
          const path = item.path || [];
          const leafOriginal = item.leaf; // HTMLElement reference

          // Build/attach container chain
          for (let i = 0; i < path.length; i++) {
            const current = path[i];
            getContainerClone(current);

            if (i > 0) attachChild(path[i - 1], current);
          }

          // Attach top-level container to rootClone
          if (path.length > 0) {
            const topClone = getContainerClone(path[0]);
            if (topClone.parentNode !== rootClone) rootClone.appendChild(topClone);

            // Append cloned leaf to the last container clone
            const containerClone = getContainerClone(path[path.length - 1]);
            containerClone.appendChild(cloneLeaf(leafOriginal));
          } else {
            // no path: leaf goes directly under rootClone
            rootClone.appendChild(cloneLeaf(leafOriginal));
          }
        }

        return rootClone;
      }

      function splitChapterIntoViewportSlices(chapter, winHeight) {
        const adjustedWinHeight = winHeight - 20;

        // Base id for naming (e.g. "chapter001")
        const baseId = chapter.id || "chapter";
        let sliceIndex = 2; // first created slice becomes _2

        // Keep splitting as long as current chapter is taller than the viewport
        while (chapter.offsetHeight > winHeight) {
          const chapterTop = chapter.offsetTop;
          const leaves = getLeafElementsWithPath(chapter);

          const overflowLeaves = [];

          // collect overflow leaves (below cutoff) and remove them from current chapter
          for (const el of leaves) {
            const leaf = el.leaf;

            const top = leaf.offsetTop - chapterTop;
            const bottom = leaf.offsetTop - leaf.offsetHeight - chapterTop;
            // If leaf is not fully within the first "page", move it to overflow
            if (top >= adjustedWinHeight || bottom > adjustedWinHeight) {
              overflowLeaves.push(el);
            }
          }

          // Nothing moved -> prevent infinite loop (usually caused by a single huge leaf)
          if (overflowLeaves.length === 0) break;
          for (const el of overflowLeaves) {
            el.leaf.remove();
          }
          // Build the next slice
          const rootClone = document.createElement("div");
          buildFromElementPaths(overflowLeaves, rootClone, {
            stripIds: true, // avoid duplicate ids inside; we'll re-id the chapter root
            preserveOriginalSiblingOrder: true,
          });

          // Insert the newly created slice(s) after current chapter
          const insertedNodes = Array.from(rootClone.childNodes);
          chapter.after(...insertedNodes);

          // Assign ids to newly created chapter slices
          for (const node of insertedNodes) {
            if (node?.nodeType === 1 && node.classList?.contains("chapter")) {
              node.id = `${baseId}_${sliceIndex++}`;
            }
          }

          // Continue splitting on the *next* chapter slice you just inserted
          const nextSlice =
            insertedNodes.find(n => n?.nodeType === 1 && n.classList?.contains("chapter")) ||
            chapter.nextElementSibling;

          chapter = nextSlice;

          if (!chapter) break;
        }
      }



      (async () => {
        await waitForLayoutStability(document.getElementById("reader"));

        document.querySelectorAll(".chapter").forEach(chapter => {
          if (chapter.offsetHeight > window.innerHeight) {
            splitChapterIntoViewportSlices(chapter, window.innerHeight);
          }
        });

        refreshChapterIndex();
        chapterElements.forEach((el, index) => {
          el.dataset.index = index;
          observer.observe(el);
        });

        bookLoaded = true;
        FileLoaded.postMessage(chapterIds.length.toString());
        if (isDarkMode) document.body.classList.add("dark");
        window.scrollTo({ top: startingScroll });
        emitCurrentIndex();
      })();

    }


    function emitCurrentIndex() {
      const chapters = document.querySelectorAll('.chapter');

      let bestEntry = null;
      let bestRatio = 0;

      chapters.forEach((el) => {
        const rect = el.getBoundingClientRect();
        const viewportHeight = window.innerHeight;

        const visibleHeight =
          Math.min(rect.bottom, viewportHeight) - Math.max(rect.top, 0);

        const ratio = visibleHeight / rect.height;

        if (ratio > bestRatio) {
          bestRatio = ratio;
          bestEntry = el;
        }
      });

      if (bestEntry) {
        const index = Number(bestEntry.dataset.index);
        PageChanged.postMessage(index.toString());
      }
    }


    /* --------------------------------------------------
       EPUB CORE LOGIC
    -------------------------------------------------- */
    async function processEpub() {
      const containerXml = await zip
        .file("META-INF/container.xml")
        .async("text");

      const containerDoc = parseXml(containerXml);
      const rootfilePath = containerDoc
        .querySelector("rootfile")
        .getAttribute("full-path");

      const opfText = await zip.file(rootfilePath).async("text");
      const opfDoc = parseXml(opfText);

      const basePath = rootfilePath.substring(
        0,
        rootfilePath.lastIndexOf("/") + 1,
      );

      const manifest = {};
      cssFiles = [];
      chapterIds = [];

      opfDoc.querySelectorAll("manifest > item").forEach((item) => {
        const id = item.getAttribute("id");
        const href = item.getAttribute("href");
        const mediaType = item.getAttribute("media-type");

        manifest[id] = { href, mediaType };
        if (mediaType === "text/css") cssFiles.push(href);
      });

      const spine = [];
      opfDoc.querySelectorAll("spine > itemref").forEach((itemref) => {
        const href = manifest[itemref.getAttribute("idref")].href;
        spine.push(href);

        const name = href
          .split("/")
          .pop()
          .replace(/\.[^/.]+$/, "");
        chapterIds.push(name.replace(/[^a-zA-Z0-9_-]/g, "_"));
      });

      await injectCss(basePath);

      chapters = await Promise.all(
        spine.map(async (href) => {
          const text = await zip.file(basePath + href).async("text");
          const folder =
            basePath + href.substring(0, href.lastIndexOf("/") + 1);
          return convertImages(text, folder, basePath);
        }),
      );

      displayAllChapters();
    }

    /* --------------------------------------------------
       FLUTTER ENTRY POINT
    -------------------------------------------------- */
    window.loadEpubFromBase64 = async function (
      base64,
      scrollPosition,
      appTheme,
    ) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);

      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      if (appTheme == "dark") {
        isDarkMode = true;
      }
      zip = await JSZip.loadAsync(bytes);
      startingScroll = parseFloat(scrollPosition);
      await processEpub();
    };

    /*document
      .getElementById("epubInput")
      .addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
          // File IS already a Blob
          loadEpubFromBlob(file, 0, "light");
          console.log(`Loaded EPUB: ${file.name}`);
        } catch (err) {
          console.error("Failed to load EPUB:", err);
        }
      });*/

    document.addEventListener("click", (e) => {
      if (!bookLoaded) return;

      const a = e.target.closest("a");
      if (!a) return;

      const id = parseHref(a.getAttribute("href"));
      if (!id) return;

      const target = document.getElementById(id);
      if (!target) return;

      e.preventDefault();
      history.pushState(null, "", `#${id}`);
      target.scrollIntoView({ behavior: "smooth" });
    });
    function goToPage(pageIndex) {
      const pageId = chapterIds[parseInt(pageIndex) - 1]
      const target = document.getElementById(pageId);
      target.scrollIntoView();
    }

    function debounce(func, delay) {
      let timeoutId;
      return function (...args) {
        if (timeoutId) clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          func.apply(this, args);
        }, delay);
      };
    }

    function handleScroll() {
      if(bookLoaded){

        const scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop;
        const scrollHeight =
          document.documentElement.scrollHeight || document.body.scrollHeight;
        const clientHeight =
          document.documentElement.clientHeight || window.innerHeight;
        const scrollRatio = scrollTop / (scrollHeight - clientHeight);
  
        // Send to Flutter
        ReaderScrolled.postMessage(scrollTop); // or scrollRatio
      }
    }

    const debouncedScroll = debounce(handleScroll, 500);


    window.addEventListener("scroll", debouncedScroll);

  </script>
</body>

</html>